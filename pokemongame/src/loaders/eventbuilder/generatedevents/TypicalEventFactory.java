package loaders.eventbuilder.generatedevents;

import java.io.Serializable;

import effects.Event;
import gameutils.GameUtils;
import loaders.ThingLoadException;
import loaders.eventbuilder.generatedevents.globalmodification.GlobalModifierEventFactory;

/**
 * A TypicalEventFactory constructs events of a certain type using inputed values as parameters.
 * <p> For example, the RandomGoldEventFactory, always generates +x gold with a y% chance every z minutes, but the
 * values of x,y, and z are determined by input, and would be different for each instance of that RandomGoldEventFactory.
 * @author David O'Sullivan
 *
 */
public abstract class TypicalEventFactory implements Serializable { //have to implement serializable so can use lambdas in events
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	/**
	 * Generates the Event for this TypicalEventFactory
	 * @return the Event generated for this TypicalEventFactory
	 */
	public abstract Event generateEvent();
	/**
	 * Returns the description which describes the Event generated by this TypicalEventFactory
	 * @return the description which describes the Event generated by this TypicalEventFactory
	 */
	public abstract String getDescription();
	private final String[] inputs;
	/**
	 * Constructs a new TypicalEventFactory with the passed in inputs
	 * @param inputs the inputs to use for the Event paramters
	 */
	protected TypicalEventFactory(final String[] inputs) {
		this.inputs = inputs;
	}
	/**
	 * returns a new TypicalEventFactory
	 * @param eventTypeName the type of the event that a factory should be created for
	 * @param inputs the inputs to the factory
	 * @return the created TypicalEventFactory
	 */
	public static TypicalEventFactory getTypicalEventFactory(final String eventTypeName, final String[] inputs) {
		final EventType eventType = EventType.valueOf(eventTypeName.toUpperCase().trim());
		switch(eventType) {
		case DECREASE_SPAWN_PERIOD:
			return new DecreaseSpawnPeriodEventFactory(inputs);
		case GLOBAL_MODIFIER:
			return GlobalModifierEventFactory.generateGlobalModifierEventFactory(inputs);
		case LEGENDARY_CHANCE_INCREASE:
			return new LegendaryChanceIncreaseEventFactory(inputs);
		case RANDOM_GOLD:
			return new RandomGoldEventFactory(inputs);
		case MASS_REMOVAL:
			return new MassRemovalEventFactory(inputs);
		default:
			throw new ThingLoadException("invalid event type: " + eventType);
		
		}
		
	}
	/**
	 * Returns a String representation of a given time in the format of: "For the next ___ all", where ___ is the 
	 * time in milliseconds written out as short as possible (see {@link gameutils.GameUtils#millisecondsToWrittenOutTime})
	 * @param timeToExist the time in milliseconds
	 * @return the displayed string
	 */
	protected static String getTimeDisplayDescription(final long timeToExist) {
		final StringBuilder sb = new StringBuilder();
		if (timeToExist > 0) {
			sb.append("For the next ");
			final String timeVal = GameUtils.millisecondsToWrittenOutTime(timeToExist);
			sb.append(timeVal);
			sb.append(" all");
		}
		else {
			sb.append("All");
		}
		return sb.toString();
	}
	/**
	 * parses a String to a long. Accounts for scientific notation
	 * @param myLong the long to parse
	 * @return the parsed long
	 */
	protected static long parseLong(final String myLong) {
		return Double.valueOf(myLong).longValue();
	}
	/**
	 * The Type of TypicalEventFactory to generate
	 * @author David O'Sullivan
	 *
	 */
	private enum EventType {
		/**
		 * A RandomGoldEventFactory
		 */
		RANDOM_GOLD, 
		/**
		 * A LegendaryChanceIncreaseEventFactory
		 */
		LEGENDARY_CHANCE_INCREASE,
		/**
		 * A DecreaseSpawnPeriodEventFactory
		 */
		DECREASE_SPAWN_PERIOD,
		/**
		 * A GlobalModifierEventFactory
		 */
		GLOBAL_MODIFIER,
		/**
		 * A MassRemovalEventFactory
		 */
		MASS_REMOVAL;
	}
	/**
	 * Returns the inputs for this TypicalEventFactory
	 * @return the inputs for this TypicalEventFactory
	 */
	protected String[] getInputs() {
		return inputs;
	}
}
